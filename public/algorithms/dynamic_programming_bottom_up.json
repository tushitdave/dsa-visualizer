{
  "algorithm_id": "dynamic_programming_bottom_up",
  "name": "Dynamic Programming (Bottom-Up)",
  "display_name": "Dynamic Programming (Bottom-Up)",
  "category": "Dynamic Programming",
  "tags": [
    "optimization",
    "recursion",
    "tabulation",
    "subproblems"
  ],
  "overview": {
    "core_idea": "Dynamic Programming (Bottom-Up) is a method to solve problems by breaking them into smaller subproblems, solving each subproblem starting from the simplest cases, and building up to the solution of the original problem. It uses a table (or array) to store solutions to subproblems, avoiding redundant computations.",
    "when_to_use": [
      "When the problem can be divided into overlapping subproblems",
      "When the problem exhibits optimal substructure (the solution to the problem can be built from solutions to its subproblems)",
      "When you want to avoid the overhead of recursion and stack space",
      "When you need to optimize a brute-force recursive solution"
    ],
    "real_world_analogy": "Imagine building a staircase. Instead of jumping directly to the top, you start at the bottom step and build each step one at a time, using the previous step as a foundation. By the time you reach the top, you've systematically built the entire staircase without skipping any steps."
  },
  "visual_explanation": {
    "steps": [
      {
        "title": "Step 1: Initialize the table",
        "description": "Start by creating a table (array) to store solutions to subproblems. Initialize the base cases, which are the simplest subproblems that can be solved directly.",
        "array": [
          0,
          1,
          0,
          0,
          0,
          0
        ],
        "highlight": "init"
      },
      {
        "title": "Step 2: Fill the table iteratively",
        "description": "Use a loop to calculate the solution for each subproblem based on previously solved subproblems. Update the table as you go.",
        "array": [
          0,
          1,
          1,
          2,
          3,
          5
        ],
        "highlight": "process"
      }
    ]
  },
  "pseudocode": {
    "language": "generic",
    "code": "function fibonacci(n):\n    // Line 1: Initialize the table\n    dp = array of size n+1, initialized to 0\n    dp[0] = 0\n    dp[1] = 1\n    \n    // Line 2: Fill the table iteratively\n    for i from 2 to n:\n        dp[i] = dp[i-1] + dp[i-2]\n    \n    return dp[n]",
    "annotations": [
      {
        "line": 1,
        "text": "Define a function to calculate the nth Fibonacci number using bottom-up DP"
      },
      {
        "line": 2,
        "text": "Create a table (array) to store solutions to subproblems"
      },
      {
        "line": 3,
        "text": "Initialize the base case for Fibonacci(0)"
      },
      {
        "line": 4,
        "text": "Initialize the base case for Fibonacci(1)"
      },
      {
        "line": 6,
        "text": "Iterate from 2 to n to fill the table"
      },
      {
        "line": 7,
        "text": "Calculate the current Fibonacci number using the two previous numbers"
      },
      {
        "line": 9,
        "text": "Return the nth Fibonacci number"
      }
    ],
    "variables": [
      {
        "name": "dp",
        "description": "An array to store solutions to subproblems"
      },
      {
        "name": "n",
        "description": "The input number for which we want to calculate the Fibonacci value"
      }
    ],
    "key_operations": [
      "Initialize the table with base cases",
      "Iteratively calculate solutions for subproblems",
      "Return the solution for the original problem"
    ],
    "return_values": [
      {
        "value": "dp[n]",
        "condition": "When the function successfully computes the nth Fibonacci number"
      },
      {
        "value": "-1 or error",
        "condition": "If the input is invalid or out of bounds"
      }
    ],
    "flow_steps": [
      "Initialize the table",
      "Set base cases",
      "Iterate through subproblems",
      "Update the table with solutions",
      "Return the final result"
    ]
  },
  "complexity": {
    "time": {
      "best": "O(n)",
      "average": "O(n)",
      "worst": "O(n)",
      "explanation": "The algorithm iterates through the table once, performing a constant amount of work for each entry. This results in a linear time complexity.",
      "comparison_data": [
        {
          "n": 10,
          "optimized": 10,
          "bruteforce": 89
        },
        {
          "n": 100,
          "optimized": 100,
          "bruteforce": 573147844013817200000
        },
        {
          "n": 1000,
          "optimized": 1000,
          "bruteforce": "Infeasible"
        },
        {
          "n": 10000,
          "optimized": 10000,
          "bruteforce": "Infeasible"
        }
      ]
    },
    "space": {
      "complexity": "O(n)",
      "explanation": "The algorithm uses an array of size n+1 to store solutions to subproblems. This results in linear space usage."
    }
  },
  "variations": [
    {
      "name": "Space-Optimized Bottom-Up DP",
      "description": "Instead of storing all subproblem solutions, only store the last two values needed to compute the next value.",
      "use_case": "When memory usage is a concern and only the final result is needed",
      "example": {
        "input": "fibonacci(5)",
        "output": "5"
      },
      "key_change": "Replace the array with two variables to store the last two Fibonacci numbers."
    },
    {
      "name": "Bottom-Up DP for Knapsack Problem",
      "description": "A variation of bottom-up DP applied to the 0/1 Knapsack problem.",
      "use_case": "When solving optimization problems with weight and value constraints",
      "example": {
        "input": "weights = [1, 2, 3], values = [10, 15, 40], capacity = 5",
        "output": "55"
      },
      "key_change": "Use a 2D table to store the maximum value for each weight and item combination."
    }
  ],
  "common_pitfalls": [
    {
      "title": "Pitfall 1: Forgetting to Initialize Base Cases",
      "problem": "The algorithm fails because the base cases are not properly initialized.",
      "bad_code": "// Missing base cases\nfunction fibonacci(n):\n    dp = array of size n+1\n    for i from 2 to n:\n        dp[i] = dp[i-1] + dp[i-2]\n    return dp[n]",
      "good_code": "// Correctly initialize base cases\nfunction fibonacci(n):\n    dp = array of size n+1\n    dp[0] = 0\n    dp[1] = 1\n    for i from 2 to n:\n        dp[i] = dp[i-1] + dp[i-2]\n    return dp[n]",
      "explanation": "Base cases provide the foundation for solving larger subproblems. Without them, the algorithm cannot compute correct results."
    },
    {
      "title": "Pitfall 2: Using Recursion Instead of Iteration",
      "problem": "Recursion can lead to stack overflow for large inputs.",
      "bad_code": "function fibonacci(n):\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)",
      "good_code": "function fibonacci(n):\n    dp = array of size n+1\n    dp[0] = 0\n    dp[1] = 1\n    for i from 2 to n:\n        dp[i] = dp[i-1] + dp[i-2]\n    return dp[n]",
      "explanation": "Bottom-up DP avoids the overhead of recursive calls by iteratively solving subproblems."
    },
    {
      "title": "Pitfall 3: Overusing Memory",
      "problem": "Storing solutions to all subproblems when only a few are needed.",
      "bad_code": "function fibonacci(n):\n    dp = array of size n+1\n    dp[0] = 0\n    dp[1] = 1\n    for i from 2 to n:\n        dp[i] = dp[i-1] + dp[i-2]\n    return dp[n]",
      "good_code": "function fibonacci(n):\n    prev1 = 0\n    prev2 = 1\n    for i from 2 to n:\n        current = prev1 + prev2\n        prev1 = prev2\n        prev2 = current\n    return prev2",
      "explanation": "Using two variables instead of an array reduces memory usage while maintaining correctness."
    }
  ],
  "practice_exercise": {
    "title": "Hands-on Practice: Fibonacci with Bottom-Up DP",
    "description": "Walk through the algorithm step by step to compute Fibonacci(6).",
    "array": [
      0,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "target": "Compute Fibonacci(6)",
    "steps": [
      {
        "question": "What is the base case for Fibonacci(0)?",
        "hint": "Think about the simplest Fibonacci number.",
        "options": [
          "0",
          "1",
          "2",
          "Undefined"
        ],
        "correct": 0,
        "explanation": "Fibonacci(0) is defined as 0."
      },
      {
        "question": "What is the value of Fibonacci(1)?",
        "hint": "This is another base case.",
        "options": [
          "0",
          "1",
          "2",
          "Undefined"
        ],
        "correct": 1,
        "explanation": "Fibonacci(1) is defined as 1."
      },
      {
        "question": "What is Fibonacci(2) using the table?",
        "hint": "Use Fibonacci(0) and Fibonacci(1).",
        "options": [
          "1",
          "2",
          "3",
          "4"
        ],
        "correct": 0,
        "explanation": "Fibonacci(2) = Fibonacci(1) + Fibonacci(0) = 1 + 0 = 1."
      },
      {
        "question": "What is the final value of Fibonacci(6)?",
        "hint": "Use the iterative process to compute up to Fibonacci(6).",
        "options": [
          "5",
          "8",
          "13",
          "21"
        ],
        "correct": 1,
        "explanation": "Fibonacci(6) = Fibonacci(5) + Fibonacci(4) = 5 + 3 = 8."
      }
    ]
  },
  "pro_tips": [
    "Always initialize base cases correctly to avoid errors.",
    "Use space optimization techniques when memory is limited.",
    "Understand the problem's substructure to identify overlapping subproblems.",
    "Visualize the table to debug and verify your solution.",
    "Practice with common DP problems like Fibonacci, Knapsack, and Longest Common Subsequence."
  ],
  "related_problems": [
    "Climbing Stairs (LeetCode 70)",
    "House Robber (LeetCode 198)",
    "Coin Change (LeetCode 322)",
    "Longest Increasing Subsequence (LeetCode 300)",
    "0/1 Knapsack Problem"
  ]
}
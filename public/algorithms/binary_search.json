{
  "algorithm_id": "binary_search",
  "name": "Binary Search",
  "display_name": "Binary Search",
  "category": "Divide and Conquer",
  "tags": ["search", "array", "sorted", "log-n"],

  "overview": {
    "core_idea": "Eliminate half of the search space in each step by comparing the target with the middle element.",
    "when_to_use": [
      "Data is sorted (ascending or descending)",
      "Need O(log n) lookup time",
      "Random access is available (arrays, not linked lists)",
      "Finding boundaries or insertion points"
    ],
    "real_world_analogy": "Finding a word in a dictionary - you open to the middle, not page 1, and eliminate half the pages each time based on alphabetical order."
  },

  "visual_explanation": {
    "steps": [
      {
        "title": "Start with the full array",
        "description": "Define left and right boundaries to cover the entire search space.",
        "array": [1, 3, 5, 7, 9, 11, 13, 15, 17],
        "target": 7,
        "left": 0,
        "right": 8,
        "mid": null,
        "highlight": "full"
      },
      {
        "title": "Find the middle element",
        "description": "Calculate mid = (left + right) / 2. Compare array[mid] with target.",
        "array": [1, 3, 5, 7, 9, 11, 13, 15, 17],
        "target": 7,
        "left": 0,
        "right": 8,
        "mid": 4,
        "comparison": "array[4] = 9 > 7",
        "highlight": "mid"
      },
      {
        "title": "Eliminate the right half",
        "description": "Since 9 > 7, target must be in the left half. Update right = mid - 1.",
        "array": [1, 3, 5, 7, 9, 11, 13, 15, 17],
        "target": 7,
        "left": 0,
        "right": 3,
        "mid": null,
        "eliminated": [4, 5, 6, 7, 8],
        "highlight": "left-half"
      },
      {
        "title": "Find new middle",
        "description": "Calculate mid = (0 + 3) / 2 = 1. Compare array[1] with target.",
        "array": [1, 3, 5, 7, 9, 11, 13, 15, 17],
        "target": 7,
        "left": 0,
        "right": 3,
        "mid": 1,
        "comparison": "array[1] = 3 < 7",
        "highlight": "mid"
      },
      {
        "title": "Eliminate the left half",
        "description": "Since 3 < 7, target must be in the right portion. Update left = mid + 1.",
        "array": [1, 3, 5, 7, 9, 11, 13, 15, 17],
        "target": 7,
        "left": 2,
        "right": 3,
        "mid": null,
        "eliminated": [0, 1, 4, 5, 6, 7, 8],
        "highlight": "right-portion"
      },
      {
        "title": "Find new middle",
        "description": "Calculate mid = (2 + 3) / 2 = 2. Compare array[2] with target.",
        "array": [1, 3, 5, 7, 9, 11, 13, 15, 17],
        "target": 7,
        "left": 2,
        "right": 3,
        "mid": 2,
        "comparison": "array[2] = 5 < 7",
        "highlight": "mid"
      },
      {
        "title": "Narrow down further",
        "description": "Since 5 < 7, update left = mid + 1 = 3.",
        "array": [1, 3, 5, 7, 9, 11, 13, 15, 17],
        "target": 7,
        "left": 3,
        "right": 3,
        "mid": null,
        "eliminated": [0, 1, 2, 4, 5, 6, 7, 8],
        "highlight": "single"
      },
      {
        "title": "Found it!",
        "description": "mid = 3, array[3] = 7 == target. Return index 3.",
        "array": [1, 3, 5, 7, 9, 11, 13, 15, 17],
        "target": 7,
        "left": 3,
        "right": 3,
        "mid": 3,
        "found": true,
        "highlight": "found"
      }
    ]
  },

  "pseudocode": {
    "language": "generic",
    "code": "function binarySearch(array, target):\n    left = 0\n    right = array.length - 1\n    \n    while left <= right:\n        mid = left + (right - left) / 2\n        \n        if array[mid] == target:\n            return mid\n        \n        else if array[mid] < target:\n            left = mid + 1\n        \n        else:\n            right = mid - 1\n    \n    return -1",
    "annotations": [
      { "line": 1, "text": "Define the function with array and target parameters" },
      { "line": 2, "text": "Initialize left pointer at the start" },
      { "line": 3, "text": "Initialize right pointer at the end" },
      { "line": 5, "text": "Continue while search space is valid" },
      { "line": 6, "text": "Calculate middle index (overflow-safe)" },
      { "line": 8, "text": "Check if we found the target" },
      { "line": 9, "text": "Return the index if found" },
      { "line": 11, "text": "If mid value is smaller, search right half" },
      { "line": 12, "text": "Move left pointer past mid" },
      { "line": 14, "text": "If mid value is larger, search left half" },
      { "line": 15, "text": "Move right pointer before mid" },
      { "line": 17, "text": "Target not found in array" }
    ],
    "variables": [
      { "name": "left", "description": "Left boundary of search space" },
      { "name": "right", "description": "Right boundary of search space" },
      { "name": "mid", "description": "Middle index of current search space" }
    ],
    "key_operations": [
      "Calculate mid = left + (right - left) / 2",
      "Compare array[mid] with target",
      "Eliminate half of search space each iteration"
    ],
    "return_values": [
      { "value": "mid", "condition": "When array[mid] == target (found)" },
      { "value": "-1", "condition": "When left > right (not found)" }
    ],
    "flow_steps": [
      "Initialize Boundaries",
      "Calculate Middle",
      "Compare Target",
      "Eliminate Half",
      "Return Result"
    ]
  },

  "complexity": {
    "time": {
      "best": "O(1)",
      "average": "O(log n)",
      "worst": "O(log n)",
      "explanation": "Each comparison eliminates half the remaining elements. For n elements, we need at most log2(n) comparisons.",
      "comparison_data": [
        { "n": 10, "binary": 4, "linear": 10 },
        { "n": 100, "binary": 7, "linear": 100 },
        { "n": 1000, "binary": 10, "linear": 1000 },
        { "n": 10000, "binary": 14, "linear": 10000 },
        { "n": 100000, "binary": 17, "linear": 100000 },
        { "n": 1000000, "binary": 20, "linear": 1000000 }
      ]
    },
    "space": {
      "complexity": "O(1)",
      "explanation": "Only uses three variables (left, right, mid) regardless of input size."
    }
  },

  "variations": [
    {
      "name": "Find First Occurrence",
      "description": "Find the leftmost index of target in an array with duplicates.",
      "use_case": "When you need the starting position of duplicate values.",
      "example": {
        "input": "[1, 2, 2, 2, 3], target = 2",
        "output": "1 (first occurrence of 2)"
      },
      "key_change": "When found, continue searching left: right = mid - 1"
    },
    {
      "name": "Find Last Occurrence",
      "description": "Find the rightmost index of target in an array with duplicates.",
      "use_case": "When you need the ending position of duplicate values.",
      "example": {
        "input": "[1, 2, 2, 2, 3], target = 2",
        "output": "3 (last occurrence of 2)"
      },
      "key_change": "When found, continue searching right: left = mid + 1"
    },
    {
      "name": "Find Insert Position",
      "description": "Find where to insert a value to maintain sorted order.",
      "use_case": "Inserting into a sorted array efficiently.",
      "example": {
        "input": "[1, 3, 5, 7], insert 4",
        "output": "2 (insert at index 2)"
      },
      "key_change": "Return left pointer when search space is exhausted"
    },
    {
      "name": "Search in Rotated Array",
      "description": "Search in a sorted array that has been rotated.",
      "use_case": "Arrays that wrap around (e.g., circular buffers).",
      "example": {
        "input": "[4, 5, 6, 7, 0, 1, 2], target = 0",
        "output": "4"
      },
      "key_change": "Determine which half is sorted, then decide direction"
    }
  ],

  "common_pitfalls": [
    {
      "title": "Integer Overflow",
      "problem": "Calculating mid as (left + right) / 2 can overflow when left and right are large.",
      "bad_code": "mid = (left + right) / 2",
      "good_code": "mid = left + (right - left) / 2",
      "explanation": "When left and right are both close to MAX_INT, their sum overflows. The safe formula avoids this."
    },
    {
      "title": "Infinite Loop",
      "problem": "Forgetting to update left or right pointer leads to infinite loops.",
      "bad_code": "left = mid  // Wrong! Should be mid + 1",
      "good_code": "left = mid + 1  // Correct",
      "explanation": "If left = mid, when left equals mid, the loop never terminates. Always move past mid."
    },
    {
      "title": "Off-by-One Errors",
      "problem": "Using < instead of <= in the while condition.",
      "bad_code": "while (left < right)",
      "good_code": "while (left <= right)",
      "explanation": "With < alone, you miss the case where left == right, which is a valid single-element search space."
    },
    {
      "title": "Unsorted Input",
      "problem": "Binary search only works on sorted data.",
      "bad_code": "binarySearch([3, 1, 4, 1, 5], target)",
      "good_code": "binarySearch([1, 1, 3, 4, 5], target)  // Sort first!",
      "explanation": "Always verify the input is sorted, or sort it first (adds O(n log n) preprocessing)."
    }
  ],

  "practice_exercise": {
    "title": "Find 23 in the array",
    "description": "Walk through binary search step by step.",
    "array": [2, 5, 8, 12, 16, 23, 38, 56, 72, 91],
    "target": 23,
    "steps": [
      {
        "question": "What is the initial middle index?",
        "hint": "mid = (0 + 9) / 2",
        "options": ["3", "4", "5", "6"],
        "correct": 1,
        "explanation": "mid = (0 + 9) / 2 = 4 (integer division). array[4] = 16."
      },
      {
        "question": "16 < 23. Which half do we search next?",
        "hint": "If middle value is less than target...",
        "options": ["Left half [2, 5, 8, 12]", "Right half [23, 38, 56, 72, 91]"],
        "correct": 1,
        "explanation": "Since 16 < 23, the target must be in the right half. Update left = mid + 1 = 5."
      },
      {
        "question": "New search space is indices 5-9. What's the new middle?",
        "hint": "mid = (5 + 9) / 2",
        "options": ["5", "6", "7", "8"],
        "correct": 2,
        "explanation": "mid = (5 + 9) / 2 = 7. array[7] = 56."
      },
      {
        "question": "56 > 23. Which half do we search next?",
        "hint": "If middle value is greater than target...",
        "options": ["Left portion [23, 38]", "Right portion [72, 91]"],
        "correct": 0,
        "explanation": "Since 56 > 23, the target must be in the left portion. Update right = mid - 1 = 6."
      },
      {
        "question": "Search space is indices 5-6. New middle is 5. array[5] = ?",
        "hint": "Look at the array at index 5",
        "options": ["16", "23", "38", "56"],
        "correct": 1,
        "explanation": "array[5] = 23. That's our target! Return index 5."
      }
    ]
  },

  "pro_tips": [
    "Always validate that the input array is sorted before using binary search.",
    "Consider edge cases: empty array, single element, target not present.",
    "Remember the pattern: halve the search space with every comparison.",
    "For variations (first/last occurrence), remember to continue searching even after finding a match.",
    "Binary search can be applied to any monotonic function, not just arrays!"
  ],

  "related_problems": [
    "Search Insert Position (LeetCode 35)",
    "Find First and Last Position (LeetCode 34)",
    "Search in Rotated Sorted Array (LeetCode 33)",
    "Find Minimum in Rotated Sorted Array (LeetCode 153)",
    "Peak Element (LeetCode 162)"
  ]
}

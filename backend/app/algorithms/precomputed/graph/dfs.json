{
  "algorithm_id": "dfs",
  "algorithm_name": "Depth-First Search",
  "category": "graph",
  "complexity": {
    "time": {
      "best": "O(V + E)",
      "average": "O(V + E)",
      "worst": "O(V + E)",
      "explanation": "Visits each vertex once and explores each edge once. Same as BFS but with different traversal order."
    },
    "space": {
      "complexity": "O(V)",
      "explanation": "Recursion stack can go V deep in worst case (linear graph). Also need visited set of size V."
    }
  },
  "strategy": "Depth-First Graph Exploration",
  "strategy_details": "DFS explores as far as possible along each branch before backtracking. Uses recursion (implicit stack) or explicit stack. Great for pathfinding, cycle detection, and topological sorting.",
  "templates": {
    "small_6": {
      "sample_input": {
        "vertices": 6,
        "edges": [[0,1], [0,2], [1,3], [1,4], [2,4], [3,5], [4,5]],
        "start": 0
      },
      "frames": [
        {
          "step_id": 0,
          "commentary": "**DFS Starting** from vertex 0. Will go deep before backtracking. Mark 0 as visited.",
          "state": {
            "visual_type": "graph",
            "data": {
              "vertices": [0, 1, 2, 3, 4, 5],
              "edges": [[0,1], [0,2], [1,3], [1,4], [2,4], [3,5], [4,5]],
              "visited": [0],
              "stack": [0],
              "current": 0
            },
            "highlights": ["vertex_0"]
          },
          "quiz": null
        },
        {
          "step_id": 1,
          "commentary": "**At vertex 0**: Neighbors are 1, 2. Go deep - visit 1 first. Push 1 to stack, mark visited.",
          "state": {
            "visual_type": "graph",
            "data": {
              "vertices": [0, 1, 2, 3, 4, 5],
              "edges": [[0,1], [0,2], [1,3], [1,4], [2,4], [3,5], [4,5]],
              "visited": [0, 1],
              "stack": [0, 1],
              "current": 1,
              "path": [0, 1]
            },
            "highlights": ["vertex_1", "edge_0_1"]
          },
          "quiz": {
            "question": "What's the main difference between DFS and BFS traversal?",
            "options": ["DFS is faster", "DFS explores depth-first, BFS explores level-by-level", "BFS uses more memory", "They produce same result"],
            "correct": 1
          }
        },
        {
          "step_id": 2,
          "commentary": "**At vertex 1**: Neighbors are 3, 4. Continue deep - visit 3. Path: 0→1→3.",
          "state": {
            "visual_type": "graph",
            "data": {
              "vertices": [0, 1, 2, 3, 4, 5],
              "edges": [[0,1], [0,2], [1,3], [1,4], [2,4], [3,5], [4,5]],
              "visited": [0, 1, 3],
              "stack": [0, 1, 3],
              "current": 3,
              "path": [0, 1, 3]
            },
            "highlights": ["vertex_3", "edge_1_3"]
          },
          "quiz": null
        },
        {
          "step_id": 3,
          "commentary": "**At vertex 3**: Neighbor is 5. Visit 5. Path: 0→1→3→5. We've gone as deep as possible on this branch!",
          "state": {
            "visual_type": "graph",
            "data": {
              "vertices": [0, 1, 2, 3, 4, 5],
              "edges": [[0,1], [0,2], [1,3], [1,4], [2,4], [3,5], [4,5]],
              "visited": [0, 1, 3, 5],
              "stack": [0, 1, 3, 5],
              "current": 5,
              "path": [0, 1, 3, 5]
            },
            "highlights": ["vertex_5", "edge_3_5"]
          },
          "quiz": null
        },
        {
          "step_id": 4,
          "commentary": "**Vertex 5**: No unvisited neighbors. **Backtrack** to 3. 3 has no more unvisited. Backtrack to 1.",
          "state": {
            "visual_type": "graph",
            "data": {
              "vertices": [0, 1, 2, 3, 4, 5],
              "edges": [[0,1], [0,2], [1,3], [1,4], [2,4], [3,5], [4,5]],
              "visited": [0, 1, 3, 5],
              "stack": [0, 1],
              "current": 1,
              "backtracking": true
            },
            "highlights": ["vertex_1"]
          },
          "quiz": {
            "question": "What data structure does DFS implicitly use?",
            "options": ["Queue", "Stack (via recursion)", "Heap", "Hash Map"],
            "correct": 1
          }
        },
        {
          "step_id": 5,
          "commentary": "**Back at 1**: Unvisited neighbor 4. Visit 4. Path now includes 4.",
          "state": {
            "visual_type": "graph",
            "data": {
              "vertices": [0, 1, 2, 3, 4, 5],
              "edges": [[0,1], [0,2], [1,3], [1,4], [2,4], [3,5], [4,5]],
              "visited": [0, 1, 3, 5, 4],
              "stack": [0, 1, 4],
              "current": 4
            },
            "highlights": ["vertex_4", "edge_1_4"]
          },
          "quiz": null
        },
        {
          "step_id": 6,
          "commentary": "**Vertex 4**: Neighbors 5 already visited. Backtrack to 1, then to 0. At 0, visit neighbor 2.",
          "state": {
            "visual_type": "graph",
            "data": {
              "vertices": [0, 1, 2, 3, 4, 5],
              "edges": [[0,1], [0,2], [1,3], [1,4], [2,4], [3,5], [4,5]],
              "visited": [0, 1, 3, 5, 4, 2],
              "stack": [0, 2],
              "current": 2
            },
            "highlights": ["vertex_2", "edge_0_2"]
          },
          "quiz": null
        },
        {
          "step_id": 7,
          "commentary": "**DFS Complete!** All vertices visited. Traversal order: `[0, 1, 3, 5, 4, 2]`. Note the depth-first nature!",
          "state": {
            "visual_type": "graph",
            "data": {
              "vertices": [0, 1, 2, 3, 4, 5],
              "edges": [[0,1], [0,2], [1,3], [1,4], [2,4], [3,5], [4,5]],
              "traversal_order": [0, 1, 3, 5, 4, 2],
              "complete": true
            },
            "highlights": ["vertex_0", "vertex_1", "vertex_2", "vertex_3", "vertex_4", "vertex_5"]
          },
          "quiz": {
            "question": "Which problem is DFS particularly useful for?",
            "options": ["Shortest path", "Cycle detection", "Minimum spanning tree", "Maximum flow"],
            "correct": 1
          }
        }
      ]
    }
  },
  "quiz_bank": [
    {
      "question": "DFS can be used for topological sorting. What's required?",
      "options": ["Undirected graph", "Directed Acyclic Graph (DAG)", "Weighted graph", "Complete graph"],
      "correct": 1
    }
  ]
}
